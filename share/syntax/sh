# variables
syntax .sh-variable

state variable
	char '*@#?$!0-9-' END variable
	char a-zA-Z_ name
	char '{' brace
	char '(' paren
	noeat END

state name variable
	char a-zA-Z_0-9 name
	noeat END

state brace variable
	char -n "\n}" brace
	eat END

state paren special
	char ')' END special
	eat paren

# common to <<"EOF" and <<'EOF'
syntax .sh-heredoc-common

state bol string
	heredocend match
	noeat string

state string
	char "\n" bol
	eat string

state match special
	char "\n" END
	# length clamped to bol
	recolor string 1000
	noeat string

# << EOF
syntax .sh-heredoc

state start code
	char " \t" start
	char "\n" bol
	eat END error

state bol string
	heredocend match
	noeat string

state string
	# FIXME: variables etc.
	char "\n" bol
	eat string

state match special
	char "\n" END
	# length clamped to bol
	recolor string 1000
	noeat string

# << "EOF"
syntax .sh-heredoc-dq

state start string
	char \" skipws string
	eat END error

state skipws code
	char " \t" skipws
	char "\n" .sh-heredoc-common:END
	eat END error

# << 'EOF'
syntax .sh-heredoc-sq

state start string
	char \' skipws string
	eat END error

state skipws code
	char " \t" skipws
	char "\n" .sh-heredoc-common:END
	eat END error

# commands can be at beginning of line or after any of && || ; & | { ` $(
# also beginning of line can contain ( after which command is allowed
syntax sh

state start code
	char -b a-zA-Z0-9_/.- command
	char "\t " start
	char "({" start special
	noeat args

state command code
	# eat all garbage to distinguish test/run.sh from builtin test
	char -b a-zA-Z0-9_/.- command
	inlist keyword1 start keyword
	inlist keyword2 args keyword
	inlist builtin args
	bufis for for
	char \( function
	noeat args

state function special
	# don't try to validate syntax because there can be comments
	# between "()" and "{"
	char \) start special
	eat start error

state for keyword
	char " \t" for
	char a-zA-Z_ forvar
	noeat forerror

state forvar ident
	char a-zA-Z_0-9 forvar
	char " \t" forspace
	noeat forerror

state forspace code
	char " \t" forspace
	str in in
	noeat forerror

state in keyword
	char " \t" args
	noeat forerror

state forerror code
	char a-zA-Z_0-9 args error
	noeat args

state args code
	char # comment
	char "'" sq
	char '"' dq
	char \\ esc
	# FIXME: after second ` should go to args
	char ` command special
	str "$((" args special
	str "$(" command special
	char \$ .sh-variable:args
	char "\n" start
	# && is same as two &, same for |. does not matter
	char ";&|" start special
	# this might be error
	char ()} args special
	char < lt
	eat args

state comment
	char "\n" start
	eat comment

state sq string
	char "'" args string
	eat sq

state dq string
	char '"' args string
	char \\ dqescape
	char \$ .sh-variable:dq
	char '`' dqcmd
	eat dq

state dqescape special
	char '"$\`'"\n" dq special
	recolor string 1
	eat dq

state dqcmd special
	char '`' dq special
	eat dqcmd

state esc special
	eat args special

state lt special
	char < lt2
	noeat args

state lt2 special
	char < lt3
	char -- - heredoc-start special
	noeat heredoc-start

state lt3 special
	# cat <<<"string $var"
	# cat <<< $(echo $USER)
	noeat args

state heredoc-start special
	char " \t" heredoc-start
	char \" heredoc-dq
	char \' heredoc-sq
	char "\n" start error
	noeat heredoc

state heredoc-dq string
	char -bn "\"\n" heredoc-dq
	heredocbegin .sh-heredoc-dq start

state heredoc-sq string
	char -bn "\'\n" heredoc-sq
	heredocbegin .sh-heredoc-sq start

state heredoc special
	char -bn " \t\n" heredoc
	heredocbegin .sh-heredoc start

# command allowed after these
list keyword1 \
	do else elif exec if then until while

# command not allowed after these
list keyword2 \
	break case continue done esac exit export fi function in return shift

list builtin \
	alias bg bind cd caller command compgen complete test kill source \
	time declare typeset dirs disown echo enable eval fc fg getopts hash \
	help history jobs let local logout popd printf pushd pwd read \
	readonly shopt set trap type ulimit umask unalias unset wait "."
